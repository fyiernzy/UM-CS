# 1 - Rendering
---
**Q1 - What does "rendering" mean in the context of web development?**
[Learn more about Rendering](https://web.dev/articles/rendering-on-the-web)
Rendering is the process of displaying content on the web page.
- *(Anurag, n.d.)* In layman’s terms, ***web rendering*** means turning code into websites that end users can interact with.
- *(Seobility, n.d.)* ***Rendering*** is a process used in web development that turns website code into the interactive pages users see when they visit a website.

**Q2 - What does "rendering" mean in the context of React.js?**
It refers to the process of transforming React components into DOM elements that can be displayed in the browser.

**Q3 - Explain Server-Side rendering (SSR), Client-Side rendering (CSR), static-rendering, rehydration and pre-rendering.**
1. **Server-Side Rendering (SSR)**
	1. **Definition**: SSR is the process of rendering web pages on the server and sending the fully rendered HTML to the client.
	2. **Mechanism**:
		1. The client sends a request to the server.
		2. The server processes the request, renders the HTML for the requested page, and sends it to the client.
		3. The browser receives the HTML and displays the content to the user.
		4. JavaScript is then loaded and executed, making the page interactive.
	3. **Benefits**:
		- Faster initial load time and better performance for users with slow internet connections.
		- Improved SEO since search engines can easily crawl and index the fully rendered HTML.
	4. **Drawbacks**:
		1. Increased server load and potential slower response times due to server-side processing.
		2. More complex to implement compared to CSR.
		   
2. **Client-Side Rendering (CSR)**
	1. **Definition**: CSR is the process where the browser downloads a minimal HTML page and uses JavaScript to render the content dynamically on the client side.
	2. **How It Works**:
		1. The client sends a request to the server.
		2. The server responds with a minimal HTML file that includes JavaScript.
		3. The browser downloads the JavaScript, which then makes additional requests to fetch data and dynamically render the content.
	3. **Benefits**:
		- Reduces server load since rendering is handled by the client.
		- Can provide a highly interactive user experience once the JavaScript is loaded.
	4. **Drawbacks**:
		- Slower initial load time because the browser has to download and execute JavaScript before displaying content.
		- SEO can be challenging because search engines may not execute JavaScript to render content.
		  
3. **Static Rendering**
	1. **Definition**: Static rendering (or static site generation) is the process of pre-rendering web pages to static HTML files at build time.
	2. **How It Works**:
		1. During the build process, HTML files are generated for each page.
		2. These static HTML files are then served to clients as-is, without further server processing.
	3. **Benefits**:
		- Extremely fast load times since the server only needs to serve static files.
		- Reduced server load since pages are pre-rendered and cached.
	4. **Drawbacks**:
		- Less dynamic since content is generated at build time and does not change until the next build.
		- Not suitable for highly dynamic content that changes frequently.

4. **Rehydration**
	1. **Definition**:
		- Rehydration is the process of attaching event listeners and making the static HTML generated by SSR or static rendering interactive by running JavaScript on the client side.
	2. **How It Works**:
		1. The server sends pre-rendered HTML to the client.
		2. The client loads the JavaScript bundle.
		3. The JavaScript "hydrates" the static HTML, attaching event listeners and initializing the application state.
	3. **Benefits**:
		- Combines the fast initial load of SSR with the interactivity of CSR.
		- Improved SEO and performance.
	4. **Drawbacks**:
		- Potentially slower time to interactive because both HTML and JavaScript need to be processed.

5. **Pre-rendering**
	1. **Definition**:
		- Pre-rendering refers to generating static HTML for specific routes or pages of an application, either at build time (static rendering) or on-demand (incremental static regeneration).
	2. **How It Works**:
		1. At build time, HTML is generated for defined routes and stored as static files.
		2. For on-demand pre-rendering, new static pages are generated as requests come in and cached for future requests.
	3. **Benefits**:
		- Fast load times and improved SEO for pre-rendered pages.
		- Can handle a mix of static and dynamic content efficiently.
	4. **Drawbacks**:
		- Requires careful planning to determine which pages should be pre-rendered.
		- On-demand pre-rendering may introduce some complexity and require additional caching strategies.

| Concept              | Description                                                                   | Benefits                                          | Drawbacks                                                  |
| -------------------- | ----------------------------------------------------------------------------- | ------------------------------------------------- | ---------------------------------------------------------- |
| **SSR**              | Server renders HTML and sends it to the client                                | Fast initial load, improved SEO                   | Increased server load, complexity                          |
| **CSR**              | Client renders content dynamically using JavaScript                           | Reduced server load, interactive experience       | Slower initial load, SEO challenges                        |
| **Static Rendering** | Pre-rendering pages to static HTML at build time                              | Fast load times, reduced server load              | Less dynamic, not suitable for frequently changing content |
| **Rehydration**      | Attaching interactivity to static HTML on the client side                     | Combines SSR speed with CSR interactivity         | Slower time to interactive                                 |
| **Pre-rendering**    | Generating static HTML for specific routes, either at build time or on-demand | Fast load, improved SEO, efficient mix of content | Requires planning, potential complexity                    |

# 2 - React
---
**Q2.1 - What is the role of `index.js` in a React application?**
Serves as an entry point of a React application, rendering the root component into the DOM.

**Q2.2 - How does React render HTML to a webpage?**
React renders HTML by transforming JSX into JavaScript functions, then updating the DOM.

**Q2.3 - What is JSX, and what is its function in React?**
A syntax extension for JavaScript that looks like HTML, used in React to describe UI components.

**Q2.4 - Define a component in React.**
A component is a reusable, self-contained piece of UI in React.

**Q2.5 - What are props in React, and what is their function?**
Short for properties, they are used to pass data from parent to child components.

**Q2.6 - Explain prop drilling in React.**
- **Definition:**
	- Prop drilling refers to the process of passing data from a parent component to a deeply nested child component through multiple layers of intermediate components.
- **Examples**
```jsx
	const App = () => {
	  const user = { name: 'John' };
	  return <ParentComponent user={user} />;
	};
	
	const ParentComponent = ({ user }) => {
	  return <ChildComponent user={user} />;
	};
	
	const ChildComponent = ({ user }) => {
	  return <GrandChildComponent user={user} />;
	};
	
	const GrandChildComponent = ({ user }) => {
	  return <div>{user.name}</div>;
	};
```
- Disadvantages
	- Leads to cluttered, hard-to-maintain code as each intermediate component must pass props even if not used.
	- Increases complexity of the component hierarchy, making it harder to understand and manage.
	- Reduces reusability of components as they become tightly coupled with specific props.
	- Increases maintenance efforts and risk of bugs as changes in prop structure require updates to multiple components.
	- Causes performance inefficiencies due to the unnecessary re-renders in intermediate components.
- Alternatives to avoid prop drilling
	- **Context API** provides data to any level of the component tree without manual prop passing.
	- Use state management libraries such as Redux, MobX, or Zustand to manage global state and avoid deep prop passing.
	- Use higher-order components (HOCs) or render props to pass data without nested prop chains.

**Q2.7 - What is state in React, and how does it affect a SPA?**
An object that holds dynamic data influencing the rendered output; crucial for interactivity in SPAs.

**Q2.8 - What are controlled components in React?**
Components that manage their own state via React state and props.

**Q2.9 - What are the rules for using hooks in React?**
Only call hooks at the top level and only in React functions.

**Q2.10 - What is the `useState` hook, and how is it used?**
A hook that lets you add state to functional components, used as `[state, setState] = useState(initialValue)`.

**Q2.11 - What are the core principles of React?**
Component-based architecture, unidirectional data flow, declarative UI, and simplicity.

**Q2.12 - What are the rules of reacts?**
(_Rules of React – React_, n.d.)
- [Components and Hooks must be pure](https://react.dev/reference/rules#components-and-hooks-must-be-pure)
	- [Purity in Components and Hooks](https://react.dev/reference/rules/components-and-hooks-must-be-pure) is a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code.
	- [Components must be idempotent](https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent) – React components are assumed to always return the same output with respect to their inputs – props, state, and context.
	- [Side effects must run outside of render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) – Side effects should not run in render, as React can render components multiple times to create the best possible user experience.
	- [Props and state are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable) – A component’s props and state are immutable snapshots with respect to a single render. Never mutate them directly.
	- [Return values and arguments to Hooks are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#return-values-and-arguments-to-hooks-are-immutable) – Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook.
	- [Values are immutable after being passed to JSX](https://react.dev/reference/rules/components-and-hooks-must-be-pure#values-are-immutable-after-being-passed-to-jsx) – Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created.
- [React calls Components and Hooks](https://react.dev/reference/rules#react-calls-components-and-hooks)
	- [React is responsible for rendering components and hooks when necessary to optimize the user experience.](https://react.dev/reference/rules/react-calls-components-and-hooks) It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.
	- [Never call component functions directly](https://react.dev/reference/rules/react-calls-components-and-hooks#never-call-component-functions-directly) – Components should only be used in JSX. Don’t call them as regular functions.
	- [Never pass around hooks as regular values](https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values) – Hooks should only be called inside of components. Never pass it around as a regular value.
- [Rules of Hooks](https://react.dev/reference/rules#rules-of-hooks)
	- Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) when using them.
	- [Only call Hooks at the top level](https://react.dev/reference/rules/rules-of-hooks#only-call-hooks-at-the-top-level) – Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns.
	- [Only call Hooks from React functions](https://react.dev/reference/rules/rules-of-hooks#only-call-hooks-from-react-functions) – Don’t call Hooks from regular JavaScript functions.

# 3 - Web Development
---
**Q3.1 - Briefly explain the Client-Server Model, its advantages, and disadvantages.**
Architecture where clients request services from servers; advantages include centralized control, disadvantages include potential bottlenecks.

**Q3.2 - What are alternative models to the Client-Server Model?**
Peer-to-peer (P2P), decentralized networks, and service-oriented architecture (SOA).

**Q3.3 - List and explain 7 common HTTP status codes.**
- 200 OK
- 201 Created
- 204 No Content
- 400 Bad Request
- 401 Unauthorized
- 404 Not Found
- 500 Internal Server Error

**Q3.4 - What are HTTP and HTTPS, and what are their differences?**
HTTP is unsecured, while HTTPS is HTTP with SSL/TLS encryption for secure communication.

**Q3.5 - Explain the concept of Separation of Concerns in software development.**
Design principle for separating a computer program into distinct sections, each addressing a specific concern.

**Q3.6 - What are the types of persistent data storage?**
Databases (SQL, NoSQL), file systems, cookies, localStorage, and sessionStorage.

**Q3.7 - Define event subscription, entities, and static destination.**
- **Event Subscription**: Listening for specific events; 
- **Entities**: Objects that store data; 
- **Static Destination**: Fixed location for data or events.You are a professional full stack developer with deep knowledge in web development. You'll be given a list of question enclosed in triple quotation mark. You task is to answer these question in point from. Keep the answer short yet clear.

**Q3.8 - What is a RESTful API?**
An API that adheres to REST principles, using standard HTTP methods and stateless communication.

**Q3.9 - What is the difference between stateful and stateless systems?**
Stateful systems maintain state across sessions, while stateless systems treat each request as independent.

**Q3.10 - What are Single Page Applications (SPAs), and what are their advantages and disadvantages?**
- **Definition**
	- SPAs are web applications that load a single HTML page and dynamically update content.
- **How SPAs Work**:
	1. The initial request loads a minimal HTML document.
	2. JavaScript (via frameworks like React, Angular, or Vue) dynamically manipulates the DOM to render views.
	3. Navigation updates content dynamically without full page reloads.
- **Advantages**
	- - **Performance**:
	    - **Fast Interactions**: Updates only parts of the page after the initial load.
	    - **Reduced Server Load**: Only data is fetched, not full HTML pages.
	- **User Experience**:
	    - **Smooth Transitions**: App-like experience with seamless page transitions.
	    - **Offline Capabilities**: Can function offline with proper caching.
	- **Development**:
	    - **Code Reusability**: Reusable components promote DRY principles.
	    - **Simplified Routing**: Flexible and manageable client-side routing.
- **Disadvantages** 
    - **SEO**: Harder for search engines to index client-rendered content. Mitigated with SSR or pre-rendering.
    - Longer initial load due to downloading the entire app.    
    - Functionality issues arise for users with disabled JavaScript or older browsers.
    - Managing state and navigation can be complex.
    - More susceptible to XSS and other security risks.

**Q3.11 - Explain REST Principles**
REST (Representational State Transfer) is an architectural style for designing networked applications. It relies on a stateless, client-server protocol, typically HTTP. Key principles of RESTful systems include:
- **Separation of Concerns**: Clients handle the UI; servers handle data storage and business logic.  This allows independent evolution.
- **Stateless**: No client context stored on server. Each request must contain all necessary information for the server to fulfill the request.
- **Cacheability**: Server responses should be marked as cacheable or non-cacheable to improve efficiency and reduce load. by reusing responses.
- **Uniform Interface**: Simplified interaction using standard HTTP methods (GET, POST, PUT, DELETE) and URIs.
	- **Resource Identification**: Each resource has a unique URI.
	- **Manipulation Through Representations**: Interact with resources using representations (e.g., JSON, XML).
	- **Self-descriptive Messages**: Messages include all information needed for processing (e.g., HTTP headers).
	- **HATEOAS**: Clients navigate the application through hypermedia provided by the server.
- **Layered Architecture**: Clients cannot tell if they are connected to the end server or an intermediary. This promotes scalability through load balancing and shared caches.

# Reference
---
1. Anurag. (n.d.). _What the Heck Is Web Rendering, and Why Should You Care?_ Locofy Blogs. https://www.locofy.ai/blog/what-the-heck-is-web-rendering
2. Seobility. (n.d.). _Rendering (Web Development): Definition - Seobility Wiki_. https://www.seobility.net/en/wiki/Rendering
3. _Rules of React – React_. (n.d.). https://react.dev/reference/rules#react-calls-components-and-hooks