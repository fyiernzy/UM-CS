# Question 1
**You are required to compute Fibonacci numbers using the following methods:**
1. Memoization (Top Down) Fibonacci
   ```python
	def fib_memo(n):
	    def fib(n, memo):
	        if n == 0 or n == 1:
	            return n
	        memo[n] = fib(n - 1, memo) + fib(n - 2, memo)
	        return memo[n]
    return fib(n, memo=([0] * (n + 1)))
	```
2. Tabulation (Bottom Up) Fibonacci
	```python
   def fib_dp(n):
	   dp = [0, 1] + [0] * (n - 1)
		   for i in range(2, n + 1):
		       dp[i] = dp[i - 1] + dp[i - 2]
	   return dp[n]
	```

**Discuss the differences between the two methods and the running time complexity as compared to the naïve approach**

1. **Approach**
	- **Memoization**: This method uses recursion to break down the problem into subproblems and stores the results of these subproblems to avoid redundant calculations. <mark style="background: #FFB86CA6;">It starts from the top (the given `n`) and works its way down to the base cases (0 and 1).</mark>
	  
	- **Tabulation**: This method uses an iterative approach to build the solution from the bottom up. <mark style="background: #FFB86CA6;">It starts from the base cases (0 and 1) and iteratively computes the Fibonacci values up to `n`.</mark>

2. **Function Calls**:

    - **Memoization**: Involves recursive function calls, which adds overhead due to the function call stack.
      
    - **Tabulation**: Uses a simple loop to fill in the Fibonacci values, resulting in less overhead and better constant factors in practice.

### Time Complexity

- **Memoization**: The time complexity is $O(n)$. Each Fibonacci number is computed once, and the result is stored in the `memo` array. Accessing and updating the `memo` array takes constant time.
  
- **Tabulation**: The time complexity is $O(n)$. The method iteratively fills in the `dp` array in a linear pass from 2 to `n`.
  
- **Naive Recursive Approach**: The time complexity is $O(2^n)$. This method computes the same subproblems multiple times, leading to exponential time complexity.

# Question 2
### Problem Statement

In the rod-cutting problem, we are given a rod of length `n` inches and a table of prices `p[i]` for `i = 1, 2, ..., n`. Here, `p[i]` is the price of a rod of length `i` inches. Find the optimal way of cutting the rod so that the maximum revenue can be generated by selling the pieces using the memoized approach.
### Implementation

```python
def rod_cutting_memo(lengths, prices, max_length):
    memo = [[-1] * (max_length + 1) for _ in range(len(lengths) + 1)]
    
    def recursion(lengths, prices, i, remaining_length, memo):
        if i == 0 or remaining_length == 0:
            return 0
        if memo[i][remaining_length] != -1:
            return memo[i][remaining_length]
        if lengths[i - 1] > remaining_length:
            memo[i][remaining_length] = recursion(lengths, prices, i - 1, remaining_length, memo)
        else:
            memo[i][remaining_length] = max(
                recursion(lengths, prices, i - 1, remaining_length, memo),
                prices[i - 1] + recursion(lengths, prices, i, remaining_length - lengths[i - 1], memo)
            )
        return memo[i][remaining_length]
    
    return recursion(lengths, prices, len(lengths), max_length, memo)

# Example usage
lengths = [1, 2, 3, 4]
prices = [2, 5, 7, 8]
max_length = 5
print("Maximum Revenue:", rod_cutting_memo(lengths, prices, max_length))
```

### Explanation

The memoization or top-down approach starts by declaring a 2D table with the rod length to be cut as its columns and the number of cuts as its rows. We add 1 to both dimensions to simplify accessing the table. The algorithm checks the `memo` table to see if there is an already-computed value. If it exists, it directly returns the stored value. Otherwise, it computes the value.

If the current cut length is larger than the remaining rod length, the algorithm ignores this cut and checks the next smaller cut. If the current cut length fits, it compares the value of including this cut versus not including it to determine the maximum revenue. This approach starts from the top (largest cut) and works down to the smallest cut, hence the name "Top-Down Approach."

# Question 3
Given an array $A = [2, 6, 1, 3]$, find the number of subsets with a sum equal to 9. Provide the tabular method dynamic programming pseudocode and show the two-dimensional array used to find the solution.

```python
def find_subsets_with_sum(nums, total):
    dp = [[[] for _ in range(total + 1)] for _ in range(len(nums) + 1)]
  
    # Initialize dp array for sum 0
    for i in range(len(nums) + 1):
        dp[i][0] = [[]]

    for i in range(1, len(nums) + 1):
        for j in range(total + 1):
            if nums[i - 1] > j:
                dp[i][j] = dp[i - 1][j]
            else:
                dp[i][j] = dp[i - 1][j] + [subset + [nums[i - 1]]
                                           for subset in dp[i - 1][j - nums[i - 1]]]

    # Printing the dp array for understanding
    for row in dp:
        print(row)

    return dp[len(nums)][total]

subsets = find_subsets_with_sum([2, 6, 1, 3], 9)
print("Subsets with sum 9:", subsets)
```

### Explanation:

Instead of initializing `dp` with `[0]`, we declare a `dp` array where each element is a list of subsets. The format of `dp` is $\left[[x_1, x_2, \ldots, x_n], [y_1, y_2, \ldots, y_m], \ldots \right]$. Hence, it is actually a 2-dimensional array where each cell contains a list of subsets.

#### Core Idea:

1. **Initialization**:
    - `dp[i][0]` is initialized to `[[]]` for all `i` because there's one way to make a sum of 0: by using no elements (the empty subset).

2. **Filling the DP Table**:
    - If `nums[i - 1]` is greater than `j`, carry forward the subsets from the previous row (`dp[i - 1][j]`).
    - Otherwise, `dp[i][j]` is the union of:
        - Subsets that do not include the current element (`dp[i - 1][j]`).
        - Subsets that include the current element (`dp[i - 1][j - nums[i - 1]]`), with the current element added to each of these subsets.
        - Unlike the knapsack problem that compares two values, this approach takes all possible combinations.
        - If `dp[i-1][j-nums[i-1]]` is `[]`, it means there are no subsets for that sum, so nothing is added.
