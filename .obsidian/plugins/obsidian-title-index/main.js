/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * The main class to add markdown index.
 *
 * Inspired by firjq (https://github.com/firejq/markdown_index/blob/master/src/MarkdownIndex.ts)
 *
 * modify by legendmohe
 */
const REGEX_HEADING = /^(#+) (.*)/;
class MarkdownIndex {
    constructor() {
        // index base configuration for user, default value is "#"
        this._indexBase = "#";
    }
    _addPrefix(line, prefix, markCount) {
        // remove previous index
        let markIndex = line.indexOf(this._indexBase);
        if (markIndex == -1) {
            markIndex = 0;
        }
        var re = new RegExp("(^\\s*\\" + this._indexBase + "+)\\s*((\\d+\\.)+)\\s+", "g");
        line = line.replace(re, "$1");
        return (line.substr(0, markIndex + markCount) +
            " " +
            prefix +
            " " +
            line.substr(markIndex + markCount).trim());
    }
    _countStartsWith(fliter, chars) {
        let count = 0;
        chars.some(element => {
            if (fliter(element)) {
                count++;
                return false;
            }
            else {
                return true;
            }
        });
        return count;
    }
    _addIndex(content, lastMarkCount, prefix, cursor) {
        // leave the normal line and count this._indexBase
        let targetMarkCount = 0;
        // mark the current line whether is in the ``` code area
        let isInCodeArea = false;
        while (cursor < content.length) {
            let line = content[cursor];
            if (line.startsWith("```")) {
                isInCodeArea = !isInCodeArea;
                cursor++;
                continue;
            }
            if (isInCodeArea == false && line.match(REGEX_HEADING)) {
                // find the start mark count
                targetMarkCount = this._countStartsWith((x) => {
                    return x == this._indexBase;
                }, line.split(""));
                break;
            }
            cursor++;
        }
        let seq = 1;
        while (cursor < content.length) {
            let markCount = this._countStartsWith((x) => {
                return x == this._indexBase;
            }, content[cursor].split(""));
            if (markCount == targetMarkCount && markCount > lastMarkCount) {
                let curPrefix = prefix + seq + ".";
                content[cursor] = this._addPrefix(content[cursor], curPrefix, markCount);
                seq++;
                // deep first search
                cursor = this._addIndex(content, markCount, curPrefix, cursor + 1);
            }
            else if (markCount <= lastMarkCount) {
                // rollback 1 row
                cursor--;
                break;
            }
            cursor++;
        }
        return cursor;
    }
    addMarkdownIndex(content) {
        this._addIndex(content, 0, "", 0);
        return content;
    }
}

class titleIndexPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.addCommand({
                id: "add-markdown-index",
                name: "add-markdown-index",
                checkCallback: (checking) => {
                    const markdownView = this.app.workspace.getActiveViewOfType(obsidian.MarkdownView);
                    if (markdownView) {
                        if (!checking) {
                            const editor = markdownView.editor;
                            const cursor = editor.getCursor();
                            const lines = editor.getValue().split("\n");
                            const markdownIndex = new MarkdownIndex();
                            const newlines = markdownIndex.addMarkdownIndex(lines);
                            editor.setValue(newlines.join("\n"));
                            editor.setCursor(cursor);
                        }
                        return true;
                    }
                    return false;
                },
            });
        });
    }
}

module.exports = titleIndexPlugin;


/* nosourcemap */